#version 330 core
out vec3 FragColor;
in vec2 UV;
in vec3 Normal;
in vec3 FragmentPosition_WorldSpace;

uniform sampler2D texture_diffuse1;
uniform sampler2D shadow_map2;

uniform vec3 lightPos;

uniform vec3 ambint;
in vec4 ShadowCoord;


vec4 toonshade(vec3 color, vec3 amInt, vec3 diffInt)
{
	//compute half vector 
	vec3 viewDir = normalize(-FragmentPosition_WorldSpace);
	vec3 lightDir = vec3(0,1,0);
	vec3 halfVector = normalize(lightDir + viewDir);

	//normalise vectors
	vec3 lightToEye = lightPos - -FragmentPosition_WorldSpace;
	vec3 normal = normalize(Normal);
	vec3 noEye = normalize(normalize(lightToEye));

	//compute ADS - floor the diffuse for the flat light effecting
	vec3 ambient =  amInt * vec3(0.3);
	float sDotN = max(dot(noEye, normal), 0.0);
	vec3 diffuse = color * vec3(0.3) * floor(sDotN * 2) * (1.0 /2);
	vec3 specular = vec3(1) * pow(max(0.0, dot(normalize(FragmentPosition_WorldSpace), halfVector)), 0.2) * 1.0;



	vec3 projCoors = ShadowCoord.xyz / ShadowCoord.w;
	projCoors = projCoors * 0.5 + 0.5;

	//texelFetch(shadow_map2, 0);


	
	
	vec3 lighting = vec3(0,0,1) * ambient + vec3(0,0,1) * diffuse +  vec3(0,0,1) * specular; //fixed full black issue 
	


	 //fixed full black issue 

	return vec4(lighting, 1.0);
}




void main()
{    

	
	//float shadow = textureProj(shadow_map1, ShadowCoord) - removed as shadow was full black;
	//float depth = texture(shadow_map2, ShadowCoord.xy).r;
	
	float offset = 0.001;

	//check all neigbours - if all !1 render blue
	float centre = texture(shadow_map2, ShadowCoord.xy).r;
	float top = texture(shadow_map2, vec2(ShadowCoord.x, ShadowCoord.y + offset)).r;
	float bottom = texture(shadow_map2, vec2(ShadowCoord.x, ShadowCoord.y - offset)).r;

	float left = texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y)).r;
	float right = texture(shadow_map2, vec2(ShadowCoord.x + offset, ShadowCoord.y)).r;

	float topLeft = texture(shadow_map2, vec2(ShadowCoord.x + offset, ShadowCoord.y + offset)).r;
	float topRight = texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y + offset)).r;

	float centreLeft = texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y)).r;
	float centreRight = texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y)).r;

	float bottomLeft =  texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y - offset)).r;
	float bottomRight =  texture(shadow_map2, vec2(ShadowCoord.x - offset, ShadowCoord.y - offset)).r;

	//compute the border of the depth
	
	vec3 color;
	bool neigboursHoodCheck = ((top != 1) && (bottom != 1) && (left != 1) && (right != 1) && (topLeft != 1) && (topRight != 1) && (centreLeft != 1) && (centreRight != 1) && (bottomLeft != 1) && (bottomRight != 1));
	if(centre != 1)
	{
		if(neigboursHoodCheck == true)
		{
			color = vec3(0,0,1);
		}
		else //if not true assume we're on the border
		{
			color = vec3(1,1,1);
		}
	}
	else
	{
		color = vec3(0,0,1); //if 1 no depth value present no check needed
	}

	FragColor = color;
}